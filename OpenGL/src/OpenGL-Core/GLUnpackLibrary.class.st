"
I decorate a GLExternalLibrary to automatically unpack enum objects to integers for API calls.

I am part of a GLContext's default library setup, making it unnecessary for users to manually create me.
"
Class {
	#name : #GLUnpackLibrary,
	#superclass : #GLLibrary,
	#instVars : [
		'library'
	],
	#category : #'OpenGL-Core',
	#'squeak_changestamp' : 'stlu 7/22/2021 19:22'
}

{
	#category : #'instance creation',
	#'squeak_changestamp' : 'stlu 4/17/2021 10:29'
}
GLUnpackLibrary class >> around: aLibrary [

	^ self new
		library: aLibrary;
		context: aLibrary context;
		yourself
]

{
	#category : #'error handling',
	#'squeak_changestamp' : 'stlu 7/22/2021 17:25'
}
GLUnpackLibrary >> compilePassthrough: methodSignature [

	| source |
	source := self passthroughTemplate format: { methodSignature }.
	^ self class compileSilently: source classified: #'*autogenerated'
]

{
	#category : #'error handling',
	#'squeak_changestamp' : 'stlu 7/22/2021 19:04'
}
GLUnpackLibrary >> compileUnpack: methodSignature pragmas: methodPragmas [

	| argPragmas sigParts source |
	argPragmas := methodPragmas select: [:pragma |
						pragma keyword beginsWith: 'glArg'].
	sigParts := methodSignature findTokens.
	source := String streamContents: [:stream |
		stream
			nextPutAll: methodSignature;
			cr; cr; tab;
			nextPutAll: '^ library'.
		1 to: argPragmas size do: [:argIndex |
			| selPart argName argPragma argType |
			selPart := sigParts at: argIndex * 2 - 1.
			argName := sigParts at: argIndex * 2.
			argPragma := argPragmas at: argIndex.
			argType := argPragma argumentAt: 2.
			stream
				cr; tab; tab;
				nextPutAll: selPart;
				space;
				nextPutAll: argName.
			(self typesToUnpack includes: argType) ifTrue: [
				stream nextPutAll: ' value']]].
	self class compileSilently: source classified: #'*autogenerated'.
]

{
	#category : #'error handling',
	#'squeak_changestamp' : 'stlu 4/16/2021 14:56'
}
GLUnpackLibrary >> doesNotUnderstand: aMessage [

	(self install: aMessage selector) ifNotNil: [
		^ aMessage sendTo: self].
	
	^ super doesNotUnderstand: aMessage
]

{
	#category : #'error handling',
	#'squeak_changestamp' : 'stlu 7/22/2021 17:29'
}
GLUnpackLibrary >> install: aSelector [

	| registryMethod signature pragmas |
	registryMethod := GLRegistry compiledMethodAt: aSelector ifAbsent: [^ nil].
	"assumption: method signature is on a single line ended by a carriage return."
	signature := registryMethod getSource asString copyUpTo: Character cr.
	pragmas := registryMethod pragmas.
	registryMethod numArgs = 0
		ifTrue: [self compilePassthrough: signature]
		ifFalse: [self compileUnpack: signature pragmas: pragmas].
]

{
	#category : #accessing,
	#'squeak_changestamp' : 'stlu 4/15/2021 22:23'
}
GLUnpackLibrary >> library [

	^ library
]

{
	#category : #accessing,
	#'squeak_changestamp' : 'stlu 4/17/2021 10:29'
}
GLUnpackLibrary >> library: aLibrary [

	library := aLibrary
]

{
	#category : #'error handling',
	#'squeak_changestamp' : 'stlu 7/22/2021 17:25'
}
GLUnpackLibrary >> passthroughTemplate [

	^ '{1}

	^ library {1}'
]

{
	#category : #'error handling',
	#'squeak_changestamp' : 'stlu 7/22/2021 19:12'
}
GLUnpackLibrary >> typesToUnpack [

	"we are very liberal with the types we unpack using #value.
	reason being that enums can also be valid inputs for arguments with these more generic types.
	this should not pose a problem, since all other valid objects are idempotent to #value.
	may even need to be expanded in the future."
	^ #( 'GLenum' 'GLbitfield' 'GLint' 'GLuint' )
]
